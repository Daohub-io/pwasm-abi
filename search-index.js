var N = null;var searchIndex = {};
searchIndex["pwasm_abi"]={"doc":"WASM ABI Tools","items":[[0,"eth","pwasm_abi","Legacy Ethereum-like ABI generator",N,N],[3,"Stream","pwasm_abi::eth","Stream interpretation of incoming payload",N,N],[3,"Sink","","Sink for returning number of arguments",N,N],[4,"Error","","Error for decoding rust types from stream",N,N],[13,"InvalidBool","","Invalid bool for provided input",0,N],[13,"InvalidU32","","Invalid u32 for provided input",0,N],[13,"InvalidU64","","Invalid u64 for provided input",0,N],[13,"UnexpectedEof","","Unexpected end of the stream",0,N],[13,"InvalidPadding","","Invalid padding for fixed type",0,N],[13,"Other","","Other error",0,N],[11,"new","","New stream for known payload",1,N],[11,"pop","","Pop next argument of known type",1,[[["self"]],["result",["error"]]]],[11,"position","","Current position for the stream",1,[[["self"]],["usize"]]],[11,"advance","","Advance stream position for `amount` bytes",1,[[["self"],["usize"]],["result",["usize","error"]]]],[11,"finish_advance","","Finish current advance, advancing stream to the next 32 byte step",1,[[["self"]]]],[11,"payload","","Stream payload",1,N],[11,"peek","","Peek next byte in stream",1,[[["self"]],["u8"]]],[11,"new","","New sink with known capacity",2,[[["usize"]],["self"]]],[11,"push","","Consume `val` to the Sink",2,[[["self"],["t"]]]],[11,"drain_to","","Drain current Sink to the target vector",2,[[["self"],["vec"]]]],[11,"finalize_panicking","","Consume current Sink to produce a vector with content. May panic if declared number of arguments does not match the resulting number of bytes should be produced.",2,[[["self"]],["vec",["u8"]]]],[11,"preamble_mut","","Mutable reference to the Sink preamble",2,[[["self"]],["vec"]]],[11,"heap_mut","","Mutable reference to the Sink heap",2,[[["self"]],["vec"]]],[8,"AsLog","","As log trait for how primitive types are represented as indexed arguments of the event log",N,N],[10,"as_log","","Convert type to hash representation for the event log.",3,[[["self"]],["h256"]]],[8,"AbiType","","Abi type trait",N,N],[10,"decode","","Insantiate type from data stream Should never be called manually! Use stream.pop()",4,[[["stream"]],["result",["error"]]]],[10,"encode","","Push type to data sink Should never be called manually! Use sink.push(val)",4,[[["self"],["sink"]]]],[18,"IS_FIXED","","Whether type has fixed length or not",4,N],[8,"EndpointInterface","","Endpoint interface for contracts",N,N],[10,"dispatch","","Dispatch payload for regular method",5,N],[10,"dispatch_ctor","","Dispatch constructor payload",5,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"eq","","",0,[[["self"],["error"]],["bool"]]],[0,"types","pwasm_abi","Custom types which AbiType supports",N,N],[3,"Vec","pwasm_abi::types","A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.",N,N],[3,"H32","","Unformatted binary data of fixed length.",N,N],[12,"0","","",6,N],[3,"H64","","Unformatted binary data of fixed length.",N,N],[12,"0","","",7,N],[3,"H128","","Unformatted binary data of fixed length.",N,N],[12,"0","","",8,N],[3,"H160","","Unformatted binary data of fixed length.",N,N],[12,"0","","",9,N],[3,"H256","","Unformatted binary data of fixed length.",N,N],[12,"0","","",10,N],[3,"H264","","Unformatted binary data of fixed length.",N,N],[12,"0","","",11,N],[3,"H512","","Unformatted binary data of fixed length.",N,N],[12,"0","","",12,N],[3,"H520","","Unformatted binary data of fixed length.",N,N],[12,"0","","",13,N],[3,"H1024","","Unformatted binary data of fixed length.",N,N],[12,"0","","",14,N],[3,"H2048","","Unformatted binary data of fixed length.",N,N],[12,"0","","",15,N],[6,"Address","","",N,N],[3,"U256","","Little-endian large integer type",N,N],[12,"0","","",16,N],[11,"as_log","","",16,[[["self"]],["h256"]]],[11,"as_log","","",10,[[["self"]],["h256"]]],[11,"as_log","","",17,[[["self"]],["h256"]]],[11,"decode","","",18,[[["stream"]],["result",["error"]]]],[11,"encode","","",18,[[["self"],["sink"]]]],[11,"decode","","",16,[[["stream"]],["result",["error"]]]],[11,"encode","","",16,[[["self"],["sink"]]]],[11,"decode","","",17,[[["stream"]],["result",["error"]]]],[11,"encode","","",17,[[["self"],["sink"]]]],[11,"decode","","",10,[[["stream"]],["result",["error"]]]],[11,"encode","","",10,[[["self"],["sink"]]]],[11,"decode","","",18,[[["stream"]],["result",["error"]]]],[11,"encode","","",18,[[["self"],["sink"]]]],[11,"new","","Constructs a new, empty `Vec<T>`.",18,[[],["vec"]]],[11,"with_capacity","","Constructs a new, empty `Vec<T>` with the specified capacity.",18,[[["usize"]],["vec"]]],[11,"from_raw_parts","","Creates a `Vec<T>` directly from the raw components of another vector.",18,N],[11,"capacity","","Returns the number of elements the vector can hold without reallocating.",18,[[["self"]],["usize"]]],[11,"reserve","","Reserves capacity for at least `additional` more elements to be inserted in the given `Vec<T>`. The collection may reserve more space to avoid frequent reallocations. After calling `reserve`, capacity will be greater than or equal to `self.len() + additional`. Does nothing if capacity is already sufficient.",18,N],[11,"reserve_exact","","Reserves the minimum capacity for exactly `additional` more elements to be inserted in the given `Vec<T>`. After calling `reserve_exact`, capacity will be greater than or equal to `self.len() + additional`. Does nothing if the capacity is already sufficient.",18,N],[11,"try_reserve","","Tries to reserve capacity for at least `additional` more elements to be inserted in the given `Vec<T>`. The collection may reserve more space to avoid frequent reallocations. After calling `reserve`, capacity will be greater than or equal to `self.len() + additional`. Does nothing if capacity is already sufficient.",18,[[["self"],["usize"]],["result",["collectionallocerr"]]]],[11,"try_reserve_exact","","Tries to reserves the minimum capacity for exactly `additional` more elements to be inserted in the given `Vec<T>`. After calling `reserve_exact`, capacity will be greater than or equal to `self.len() + additional`. Does nothing if the capacity is already sufficient.",18,[[["self"],["usize"]],["result",["collectionallocerr"]]]],[11,"shrink_to_fit","","Shrinks the capacity of the vector as much as possible.",18,N],[11,"shrink_to","","Shrinks the capacity of the vector with a lower bound.",18,N],[11,"into_boxed_slice","","Converts the vector into [`Box<[T]>`][owned slice].",18,[[["self"]],["box"]]],[11,"truncate","","Shortens the vector, keeping the first `len` elements and dropping the rest.",18,N],[11,"as_slice","","Extracts a slice containing the entire vector.",18,N],[11,"as_mut_slice","","Extracts a mutable slice of the entire vector.",18,N],[11,"set_len","","Sets the length of a vector.",18,N],[11,"swap_remove","","Removes an element from the vector and returns it.",18,[[["self"],["usize"]],["t"]]],[11,"insert","","Inserts an element at position `index` within the vector, shifting all elements after it to the right.",18,N],[11,"remove","","Removes and returns the element at position `index` within the vector, shifting all elements after it to the left.",18,[[["self"],["usize"]],["t"]]],[11,"retain","","Retains only the elements specified by the predicate.",18,N],[11,"dedup_by_key","","Removes all but the first of consecutive elements in the vector that resolve to the same key.",18,N],[11,"dedup_by","","Removes all but the first of consecutive elements in the vector satisfying a given equality relation.",18,N],[11,"push","","Appends an element to the back of a collection.",18,N],[11,"pop","","Removes the last element from a vector and returns it, or [`None`] if it is empty.",18,[[["self"]],["option"]]],[11,"append","","Moves all the elements of `other` into `Self`, leaving `other` empty.",18,N],[11,"drain","","Creates a draining iterator that removes the specified range in the vector and yields the removed items.",18,[[["self"],["r"]],["drain"]]],[11,"clear","","Clears the vector, removing all values.",18,N],[11,"len","","Returns the number of elements in the vector, also referred to as its 'length'.",18,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the vector contains no elements.",18,[[["self"]],["bool"]]],[11,"split_off","","Splits the collection into two at the given index.",18,[[["self"],["usize"]],["vec"]]],[11,"resize_with","","Resizes the `Vec` in-place so that `len` is equal to `new_len`.",18,N],[11,"resize","","Resizes the `Vec` in-place so that `len` is equal to `new_len`.",18,N],[11,"extend_from_slice","","Clones and appends all elements in a slice to the `Vec`.",18,N],[11,"resize_default","","Resizes the `Vec` in-place so that `len` is equal to `new_len`.",18,N],[11,"dedup","","Removes consecutive repeated elements in the vector.",18,N],[11,"remove_item","","Removes the first instance of `item` from the vector if the item exists.",18,[[["self"],["t"]],["option"]]],[11,"splice","","Creates a splicing iterator that replaces the specified range in the vector with the given `replace_with` iterator and yields the removed items. `replace_with` does not need to be the same length as `range`.",18,[[["self"],["r"],["i"]],["splice"]]],[11,"drain_filter","","Creates an iterator which uses a closure to determine if an element should be removed.",18,[[["self"],["f"]],["drainfilter"]]],[11,"hash","","",16,N],[11,"add","","",16,[[["self"],["t"]],["u256"]]],[11,"clone","","",16,[[["self"]],["u256"]]],[11,"bitand","","",16,[[["self"],["u256"]],["u256"]]],[11,"shr_assign","","",16,N],[11,"eq","","",16,[[["self"],["u256"]],["bool"]]],[11,"ne","","",16,[[["self"],["u256"]],["bool"]]],[11,"mul_assign","","",16,N],[11,"mul_assign","","",16,N],[11,"mul_assign","","",16,N],[11,"mul_assign","","",16,N],[11,"mul_assign","","",16,N],[11,"mul_assign","","",16,N],[11,"mul_assign","","",16,N],[11,"mul_assign","","",16,N],[11,"mul_assign","","",16,N],[11,"mul_assign","","",16,N],[11,"as_ref","","",16,[[["self"]],["u256"]]],[11,"div_assign","","",16,N],[11,"not","","",16,[[["self"]],["u256"]]],[11,"shl","","",16,[[["self"],["t"]],["u256"]]],[11,"add_assign","","",16,N],[11,"div","","",16,[[["self"],["t"]],["u256"]]],[11,"sub_assign","","",16,N],[11,"shl_assign","","",16,N],[11,"rem","","",16,[[["self"],["t"]],["u256"]]],[11,"default","","",16,[[],["u256"]]],[11,"shr","","",16,[[["self"],["t"]],["u256"]]],[11,"bitxor","","",16,[[["self"],["u256"]],["u256"]]],[11,"mul","","",16,[[["self"],["u8"]],["u256"]]],[11,"mul","","",16,[[["self"],["i8"]],["u256"]]],[11,"mul","","",16,[[["self"],["isize"]],["u256"]]],[11,"mul","","",16,[[["self"],["i64"]],["u256"]]],[11,"mul","","",16,[[["self"],["u8"]],["u256"]]],[11,"mul","","",16,[[["self"],["isize"]],["u256"]]],[11,"mul","","",16,[[["self"],["u64"]],["u256"]]],[11,"mul","","",16,[[["self"],["i64"]],["u256"]]],[11,"mul","","",16,[[["self"],["i16"]],["u256"]]],[11,"mul","","",16,[[["self"],["u256"]],["u256"]]],[11,"mul","","",16,[[["self"],["i16"]],["u256"]]],[11,"mul","","",16,[[["self"],["u256"]],["u256"]]],[11,"mul","","",16,[[["self"],["u32"]],["u256"]]],[11,"mul","","",16,[[["self"],["u64"]],["u256"]]],[11,"mul","","",16,[[["self"],["i8"]],["u256"]]],[11,"mul","","",16,[[["self"],["usize"]],["u256"]]],[11,"mul","","",16,[[["self"],["u16"]],["u256"]]],[11,"mul","","",16,[[["self"],["usize"]],["u256"]]],[11,"mul","","",16,[[["self"],["u16"]],["u256"]]],[11,"rem_assign","","",16,N],[11,"from","","",16,[[["i8"]],["u256"]]],[11,"from","","",16,[[["i64"]],["u256"]]],[11,"from","","",16,[[["u16"]],["u256"]]],[11,"from","","",16,[[["isize"]],["u256"]]],[11,"from","","",16,[[["i32"]],["u256"]]],[11,"from","","",16,N],[11,"from","","",16,[[["u8"]],["u256"]]],[11,"from","","",16,[[["i16"]],["u256"]]],[11,"from","","",16,[[["u32"]],["u256"]]],[11,"from","","",16,[[["usize"]],["u256"]]],[11,"from","","",16,[[["u64"]],["u256"]]],[11,"from","","",16,[[["u256"]],["u256"]]],[11,"partial_cmp","","",16,[[["self"],["u256"]],["option",["ordering"]]]],[11,"bitor","","",16,[[["self"],["u256"]],["u256"]]],[11,"sub","","",16,[[["self"],["t"]],["u256"]]],[11,"cmp","","",16,[[["self"],["u256"]],["ordering"]]],[11,"index","","",18,N],[11,"default","","Creates an empty `Vec<T>`.",18,[[],["vec"]]],[11,"deref_mut","","",18,N],[11,"hash","","",18,N],[11,"clone","","",18,[[["self"]],["vec"]]],[11,"clone_from","","",18,N],[11,"into_iter","","Creates a consuming iterator, that is, one that moves each value out of the vector (from start to end). The vector cannot be used after calling this.",18,[[["self"]],["intoiter"]]],[11,"deref","","",18,N],[11,"from","","",18,[[["str"]],["vec",["u8"]]]],[11,"from","","",18,[[["box"]],["vec"]]],[11,"from","","",18,[[["string"]],["vec",["u8"]]]],[11,"from","","",18,[[["cow"]],["vec"]]],[11,"from","","",18,N],[11,"from","","",18,[[["binaryheap"]],["vec"]]],[11,"from","","",18,N],[11,"from","","",18,[[["vecdeque"]],["vec"]]],[11,"as_mut","","",18,[[["self"]],["vec"]]],[11,"as_mut","","",18,N],[11,"drop","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,[[["self"],["vec"]],["bool"]]],[11,"ne","","",18,[[["self"],["vec"]],["bool"]]],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"eq","","",18,N],[11,"ne","","",18,N],[11,"borrow_mut","","",18,N],[11,"from_iter","","",18,[[["i"]],["vec"]]],[11,"as_ref","","",18,N],[11,"as_ref","","",18,[[["self"]],["vec"]]],[11,"extend","","",18,N],[11,"extend","","",18,N],[11,"index_mut","","",18,N],[11,"borrow","","",18,N],[11,"partial_cmp","","",18,[[["self"],["vec"]],["option",["ordering"]]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result",["error"]]]],[11,"cmp","","",18,[[["self"],["vec"]],["ordering"]]],[11,"as_mut","","",10,N],[11,"as_mut","","",11,N],[11,"as_mut","","",15,N],[11,"as_mut","","",6,N],[11,"as_mut","","",14,N],[11,"as_mut","","",7,N],[11,"as_mut","","",13,N],[11,"as_mut","","",9,N],[11,"as_mut","","",12,N],[11,"as_mut","","",8,N],[11,"clone","","",10,[[["self"]],["h256"]]],[11,"clone","","",14,[[["self"]],["h1024"]]],[11,"clone","","",6,[[["self"]],["h32"]]],[11,"clone","","",15,[[["self"]],["h2048"]]],[11,"clone","","",7,[[["self"]],["h64"]]],[11,"clone","","",8,[[["self"]],["h128"]]],[11,"clone","","",12,[[["self"]],["h512"]]],[11,"clone","","",9,[[["self"]],["h160"]]],[11,"clone","","",13,[[["self"]],["h520"]]],[11,"clone","","",11,[[["self"]],["h264"]]],[11,"bitand","","",11,N],[11,"bitand","","",6,N],[11,"bitand","","",13,N],[11,"bitand","","",10,N],[11,"bitand","","",7,N],[11,"bitand","","",15,N],[11,"bitand","","",14,N],[11,"bitand","","",12,N],[11,"bitand","","",9,N],[11,"bitand","","",8,N],[11,"eq","","",11,[[["self"],["h264"]],["bool"]]],[11,"eq","","",15,[[["self"],["h2048"]],["bool"]]],[11,"eq","","",8,[[["self"],["h128"]],["bool"]]],[11,"eq","","",12,[[["self"],["h512"]],["bool"]]],[11,"eq","","",6,[[["self"],["h32"]],["bool"]]],[11,"eq","","",9,[[["self"],["h160"]],["bool"]]],[11,"eq","","",14,[[["self"],["h1024"]],["bool"]]],[11,"eq","","",7,[[["self"],["h64"]],["bool"]]],[11,"eq","","",13,[[["self"],["h520"]],["bool"]]],[11,"eq","","",10,[[["self"],["h256"]],["bool"]]],[11,"as_ref","","",11,N],[11,"as_ref","","",15,N],[11,"as_ref","","",13,N],[11,"as_ref","","",6,N],[11,"as_ref","","",14,N],[11,"as_ref","","",10,N],[11,"as_ref","","",12,N],[11,"as_ref","","",7,N],[11,"as_ref","","",8,N],[11,"as_ref","","",9,N],[11,"default","","",15,[[],["h2048"]]],[11,"default","","",13,[[],["h520"]]],[11,"default","","",10,[[],["h256"]]],[11,"default","","",11,[[],["h264"]]],[11,"default","","",12,[[],["h512"]]],[11,"default","","",7,[[],["h64"]]],[11,"default","","",6,[[],["h32"]]],[11,"default","","",9,[[],["h160"]]],[11,"default","","",14,[[],["h1024"]]],[11,"default","","",8,[[],["h128"]]],[11,"deref_mut","","",11,N],[11,"deref_mut","","",9,N],[11,"deref_mut","","",6,N],[11,"deref_mut","","",13,N],[11,"deref_mut","","",7,N],[11,"deref_mut","","",14,N],[11,"deref_mut","","",15,N],[11,"deref_mut","","",12,N],[11,"deref_mut","","",8,N],[11,"deref_mut","","",10,N],[11,"deref","","",7,N],[11,"deref","","",13,N],[11,"deref","","",14,N],[11,"deref","","",12,N],[11,"deref","","",6,N],[11,"deref","","",11,N],[11,"deref","","",15,N],[11,"deref","","",9,N],[11,"deref","","",10,N],[11,"deref","","",8,N],[11,"bitxor","","",7,N],[11,"bitxor","","",15,N],[11,"bitxor","","",6,N],[11,"bitxor","","",13,N],[11,"bitxor","","",8,N],[11,"bitxor","","",14,N],[11,"bitxor","","",9,N],[11,"bitxor","","",11,N],[11,"bitxor","","",12,N],[11,"bitxor","","",10,N],[11,"from","","",16,[[["h256"]],["u256"]]],[11,"from","","",11,N],[11,"from","","",16,[[["h256"]],["u256"]]],[11,"from","","",15,N],[11,"from","","",8,N],[11,"from","","",9,N],[11,"from","","",13,N],[11,"from","","",10,[[["u256"]],["h256"]]],[11,"from","","",10,[[["h160"]],["h256"]]],[11,"from","","",11,[[["u64"]],["h264"]]],[11,"from","","",12,N],[11,"from","","",10,[[["u256"]],["h256"]]],[11,"from","","",7,[[["u64"]],["h64"]]],[11,"from","","",14,N],[11,"from","","",8,N],[11,"from","","",14,N],[11,"from","","",9,[[["h256"]],["h160"]]],[11,"from","","",12,[[["u64"]],["h512"]]],[11,"from","","",10,[[["u64"]],["h256"]]],[11,"from","","",10,N],[11,"from","","",11,N],[11,"from","","",6,N],[11,"from","","",7,[[["h256"]],["h64"]]],[11,"from","","",13,[[["u64"]],["h520"]]],[11,"from","","",12,N],[11,"from","","",13,N],[11,"from","","",6,N],[11,"from","","",8,[[["u64"]],["h128"]]],[11,"from","","",10,[[["h160"]],["h256"]]],[11,"from","","",9,N],[11,"from","","",15,[[["u64"]],["h2048"]]],[11,"from","","",6,[[["u64"]],["h32"]]],[11,"from","","",9,[[["u64"]],["h160"]]],[11,"from","","",7,N],[11,"from","","",14,[[["u64"]],["h1024"]]],[11,"from","","",15,N],[11,"from","","",10,N],[11,"from","","",7,N],[11,"index_mut","","",10,[[["self"],["usize"]],["u8"]]],[11,"index_mut","","",13,N],[11,"index_mut","","",6,[[["self"],["usize"]],["u8"]]],[11,"index_mut","","",7,N],[11,"index_mut","","",15,N],[11,"index_mut","","",11,[[["self"],["usize"]],["u8"]]],[11,"index_mut","","",12,[[["self"],["usize"]],["u8"]]],[11,"index_mut","","",8,N],[11,"index_mut","","",10,N],[11,"index_mut","","",8,N],[11,"index_mut","","",9,[[["self"],["usize"]],["u8"]]],[11,"index_mut","","",9,N],[11,"index_mut","","",8,[[["self"],["usize"]],["u8"]]],[11,"index_mut","","",10,N],[11,"index_mut","","",11,N],[11,"index_mut","","",14,[[["self"],["usize"]],["u8"]]],[11,"index_mut","","",14,N],[11,"index_mut","","",9,N],[11,"index_mut","","",12,N],[11,"index_mut","","",6,N],[11,"index_mut","","",15,[[["self"],["usize"]],["u8"]]],[11,"index_mut","","",7,N],[11,"index_mut","","",14,N],[11,"index_mut","","",11,N],[11,"index_mut","","",15,N],[11,"index_mut","","",13,N],[11,"index_mut","","",12,N],[11,"index_mut","","",6,N],[11,"index_mut","","",13,[[["self"],["usize"]],["u8"]]],[11,"index_mut","","",7,[[["self"],["usize"]],["u8"]]],[11,"partial_cmp","","",14,[[["self"],["h1024"]],["option",["ordering"]]]],[11,"partial_cmp","","",6,[[["self"],["h32"]],["option",["ordering"]]]],[11,"partial_cmp","","",15,[[["self"],["h2048"]],["option",["ordering"]]]],[11,"partial_cmp","","",9,[[["self"],["h160"]],["option",["ordering"]]]],[11,"partial_cmp","","",13,[[["self"],["h520"]],["option",["ordering"]]]],[11,"partial_cmp","","",10,[[["self"],["h256"]],["option",["ordering"]]]],[11,"partial_cmp","","",8,[[["self"],["h128"]],["option",["ordering"]]]],[11,"partial_cmp","","",11,[[["self"],["h264"]],["option",["ordering"]]]],[11,"partial_cmp","","",12,[[["self"],["h512"]],["option",["ordering"]]]],[11,"partial_cmp","","",7,[[["self"],["h64"]],["option",["ordering"]]]],[11,"cmp","","",9,[[["self"],["h160"]],["ordering"]]],[11,"cmp","","",14,[[["self"],["h1024"]],["ordering"]]],[11,"cmp","","",15,[[["self"],["h2048"]],["ordering"]]],[11,"cmp","","",7,[[["self"],["h64"]],["ordering"]]],[11,"cmp","","",10,[[["self"],["h256"]],["ordering"]]],[11,"cmp","","",12,[[["self"],["h512"]],["ordering"]]],[11,"cmp","","",13,[[["self"],["h520"]],["ordering"]]],[11,"cmp","","",6,[[["self"],["h32"]],["ordering"]]],[11,"cmp","","",11,[[["self"],["h264"]],["ordering"]]],[11,"cmp","","",8,[[["self"],["h128"]],["ordering"]]],[11,"bitor","","",9,N],[11,"bitor","","",12,N],[11,"bitor","","",11,N],[11,"bitor","","",7,N],[11,"bitor","","",15,N],[11,"bitor","","",10,N],[11,"bitor","","",6,N],[11,"bitor","","",13,N],[11,"bitor","","",8,N],[11,"bitor","","",14,N],[11,"hash","","",11,N],[11,"hash","","",10,N],[11,"hash","","",14,N],[11,"hash","","",9,N],[11,"hash","","",8,N],[11,"hash","","",7,N],[11,"hash","","",6,N],[11,"hash","","",13,N],[11,"hash","","",12,N],[11,"hash","","",15,N],[11,"index","","",11,[[["self"],["usize"]],["u8"]]],[11,"index","","",11,N],[11,"index","","",15,[[["self"],["usize"]],["u8"]]],[11,"index","","",13,N],[11,"index","","",10,N],[11,"index","","",10,N],[11,"index","","",6,N],[11,"index","","",14,N],[11,"index","","",9,[[["self"],["usize"]],["u8"]]],[11,"index","","",7,N],[11,"index","","",14,[[["self"],["usize"]],["u8"]]],[11,"index","","",7,[[["self"],["usize"]],["u8"]]],[11,"index","","",8,N],[11,"index","","",12,[[["self"],["usize"]],["u8"]]],[11,"index","","",15,N],[11,"index","","",8,N],[11,"index","","",6,N],[11,"index","","",15,N],[11,"index","","",9,N],[11,"index","","",10,[[["self"],["usize"]],["u8"]]],[11,"index","","",6,[[["self"],["usize"]],["u8"]]],[11,"index","","",11,N],[11,"index","","",13,N],[11,"index","","",12,N],[11,"index","","",9,N],[11,"index","","",7,N],[11,"index","","",8,[[["self"],["usize"]],["u8"]]],[11,"index","","",13,[[["self"],["usize"]],["u8"]]],[11,"index","","",12,N],[11,"index","","",14,N],[11,"new","","Create a new, zero-initialised, instance.",6,[[],["h32"]]],[11,"zero","","Synonym for `new()`. Prefer to new as it's more readable.",6,[[],["h32"]]],[11,"len","","Get the size of this object in bytes.",6,[[],["usize"]]],[11,"as_ptr","","Returns a constant raw pointer to the value",6,N],[11,"as_mut_ptr","","Returns a mutable raw pointer to the value",6,N],[11,"clone_from_slice","","Assign self to be of the same value as a slice of bytes of length `len()`.",6,N],[11,"from_slice","","Convert a slice of bytes of length `len()` to an instance of this type.",6,N],[11,"copy_to","","Copy the data of this object into some mutable slice of length `len()`.",6,N],[11,"contains","","Returns `true` if all bits set in `b` are also set in `self`.",6,[[["self"],["h32"]],["bool"]]],[11,"is_zero","","Returns `true` if no bits are set.",6,[[["self"]],["bool"]]],[11,"low_u64","","Returns the lowest 8 bytes interpreted as a BigEndian integer.",6,[[["self"]],["u64"]]],[11,"new","","Create a new, zero-initialised, instance.",7,[[],["h64"]]],[11,"zero","","Synonym for `new()`. Prefer to new as it's more readable.",7,[[],["h64"]]],[11,"len","","Get the size of this object in bytes.",7,[[],["usize"]]],[11,"as_ptr","","Returns a constant raw pointer to the value",7,N],[11,"as_mut_ptr","","Returns a mutable raw pointer to the value",7,N],[11,"clone_from_slice","","Assign self to be of the same value as a slice of bytes of length `len()`.",7,N],[11,"from_slice","","Convert a slice of bytes of length `len()` to an instance of this type.",7,N],[11,"copy_to","","Copy the data of this object into some mutable slice of length `len()`.",7,N],[11,"contains","","Returns `true` if all bits set in `b` are also set in `self`.",7,[[["self"],["h64"]],["bool"]]],[11,"is_zero","","Returns `true` if no bits are set.",7,[[["self"]],["bool"]]],[11,"low_u64","","Returns the lowest 8 bytes interpreted as a BigEndian integer.",7,[[["self"]],["u64"]]],[11,"new","","Create a new, zero-initialised, instance.",8,[[],["h128"]]],[11,"zero","","Synonym for `new()`. Prefer to new as it's more readable.",8,[[],["h128"]]],[11,"len","","Get the size of this object in bytes.",8,[[],["usize"]]],[11,"as_ptr","","Returns a constant raw pointer to the value",8,N],[11,"as_mut_ptr","","Returns a mutable raw pointer to the value",8,N],[11,"clone_from_slice","","Assign self to be of the same value as a slice of bytes of length `len()`.",8,N],[11,"from_slice","","Convert a slice of bytes of length `len()` to an instance of this type.",8,N],[11,"copy_to","","Copy the data of this object into some mutable slice of length `len()`.",8,N],[11,"contains","","Returns `true` if all bits set in `b` are also set in `self`.",8,[[["self"],["h128"]],["bool"]]],[11,"is_zero","","Returns `true` if no bits are set.",8,[[["self"]],["bool"]]],[11,"low_u64","","Returns the lowest 8 bytes interpreted as a BigEndian integer.",8,[[["self"]],["u64"]]],[11,"new","","Create a new, zero-initialised, instance.",9,[[],["h160"]]],[11,"zero","","Synonym for `new()`. Prefer to new as it's more readable.",9,[[],["h160"]]],[11,"len","","Get the size of this object in bytes.",9,[[],["usize"]]],[11,"as_ptr","","Returns a constant raw pointer to the value",9,N],[11,"as_mut_ptr","","Returns a mutable raw pointer to the value",9,N],[11,"clone_from_slice","","Assign self to be of the same value as a slice of bytes of length `len()`.",9,N],[11,"from_slice","","Convert a slice of bytes of length `len()` to an instance of this type.",9,N],[11,"copy_to","","Copy the data of this object into some mutable slice of length `len()`.",9,N],[11,"contains","","Returns `true` if all bits set in `b` are also set in `self`.",9,[[["self"],["h160"]],["bool"]]],[11,"is_zero","","Returns `true` if no bits are set.",9,[[["self"]],["bool"]]],[11,"low_u64","","Returns the lowest 8 bytes interpreted as a BigEndian integer.",9,[[["self"]],["u64"]]],[11,"new","","Create a new, zero-initialised, instance.",10,[[],["h256"]]],[11,"zero","","Synonym for `new()`. Prefer to new as it's more readable.",10,[[],["h256"]]],[11,"len","","Get the size of this object in bytes.",10,[[],["usize"]]],[11,"as_ptr","","Returns a constant raw pointer to the value",10,N],[11,"as_mut_ptr","","Returns a mutable raw pointer to the value",10,N],[11,"clone_from_slice","","Assign self to be of the same value as a slice of bytes of length `len()`.",10,N],[11,"from_slice","","Convert a slice of bytes of length `len()` to an instance of this type.",10,N],[11,"copy_to","","Copy the data of this object into some mutable slice of length `len()`.",10,N],[11,"contains","","Returns `true` if all bits set in `b` are also set in `self`.",10,[[["self"],["h256"]],["bool"]]],[11,"is_zero","","Returns `true` if no bits are set.",10,[[["self"]],["bool"]]],[11,"low_u64","","Returns the lowest 8 bytes interpreted as a BigEndian integer.",10,[[["self"]],["u64"]]],[11,"new","","Create a new, zero-initialised, instance.",11,[[],["h264"]]],[11,"zero","","Synonym for `new()`. Prefer to new as it's more readable.",11,[[],["h264"]]],[11,"len","","Get the size of this object in bytes.",11,[[],["usize"]]],[11,"as_ptr","","Returns a constant raw pointer to the value",11,N],[11,"as_mut_ptr","","Returns a mutable raw pointer to the value",11,N],[11,"clone_from_slice","","Assign self to be of the same value as a slice of bytes of length `len()`.",11,N],[11,"from_slice","","Convert a slice of bytes of length `len()` to an instance of this type.",11,N],[11,"copy_to","","Copy the data of this object into some mutable slice of length `len()`.",11,N],[11,"contains","","Returns `true` if all bits set in `b` are also set in `self`.",11,[[["self"],["h264"]],["bool"]]],[11,"is_zero","","Returns `true` if no bits are set.",11,[[["self"]],["bool"]]],[11,"low_u64","","Returns the lowest 8 bytes interpreted as a BigEndian integer.",11,[[["self"]],["u64"]]],[11,"new","","Create a new, zero-initialised, instance.",12,[[],["h512"]]],[11,"zero","","Synonym for `new()`. Prefer to new as it's more readable.",12,[[],["h512"]]],[11,"len","","Get the size of this object in bytes.",12,[[],["usize"]]],[11,"as_ptr","","Returns a constant raw pointer to the value",12,N],[11,"as_mut_ptr","","Returns a mutable raw pointer to the value",12,N],[11,"clone_from_slice","","Assign self to be of the same value as a slice of bytes of length `len()`.",12,N],[11,"from_slice","","Convert a slice of bytes of length `len()` to an instance of this type.",12,N],[11,"copy_to","","Copy the data of this object into some mutable slice of length `len()`.",12,N],[11,"contains","","Returns `true` if all bits set in `b` are also set in `self`.",12,[[["self"],["h512"]],["bool"]]],[11,"is_zero","","Returns `true` if no bits are set.",12,[[["self"]],["bool"]]],[11,"low_u64","","Returns the lowest 8 bytes interpreted as a BigEndian integer.",12,[[["self"]],["u64"]]],[11,"new","","Create a new, zero-initialised, instance.",13,[[],["h520"]]],[11,"zero","","Synonym for `new()`. Prefer to new as it's more readable.",13,[[],["h520"]]],[11,"len","","Get the size of this object in bytes.",13,[[],["usize"]]],[11,"as_ptr","","Returns a constant raw pointer to the value",13,N],[11,"as_mut_ptr","","Returns a mutable raw pointer to the value",13,N],[11,"clone_from_slice","","Assign self to be of the same value as a slice of bytes of length `len()`.",13,N],[11,"from_slice","","Convert a slice of bytes of length `len()` to an instance of this type.",13,N],[11,"copy_to","","Copy the data of this object into some mutable slice of length `len()`.",13,N],[11,"contains","","Returns `true` if all bits set in `b` are also set in `self`.",13,[[["self"],["h520"]],["bool"]]],[11,"is_zero","","Returns `true` if no bits are set.",13,[[["self"]],["bool"]]],[11,"low_u64","","Returns the lowest 8 bytes interpreted as a BigEndian integer.",13,[[["self"]],["u64"]]],[11,"new","","Create a new, zero-initialised, instance.",14,[[],["h1024"]]],[11,"zero","","Synonym for `new()`. Prefer to new as it's more readable.",14,[[],["h1024"]]],[11,"len","","Get the size of this object in bytes.",14,[[],["usize"]]],[11,"as_ptr","","Returns a constant raw pointer to the value",14,N],[11,"as_mut_ptr","","Returns a mutable raw pointer to the value",14,N],[11,"clone_from_slice","","Assign self to be of the same value as a slice of bytes of length `len()`.",14,N],[11,"from_slice","","Convert a slice of bytes of length `len()` to an instance of this type.",14,N],[11,"copy_to","","Copy the data of this object into some mutable slice of length `len()`.",14,N],[11,"contains","","Returns `true` if all bits set in `b` are also set in `self`.",14,[[["self"],["h1024"]],["bool"]]],[11,"is_zero","","Returns `true` if no bits are set.",14,[[["self"]],["bool"]]],[11,"low_u64","","Returns the lowest 8 bytes interpreted as a BigEndian integer.",14,[[["self"]],["u64"]]],[11,"new","","Create a new, zero-initialised, instance.",15,[[],["h2048"]]],[11,"zero","","Synonym for `new()`. Prefer to new as it's more readable.",15,[[],["h2048"]]],[11,"len","","Get the size of this object in bytes.",15,[[],["usize"]]],[11,"as_ptr","","Returns a constant raw pointer to the value",15,N],[11,"as_mut_ptr","","Returns a mutable raw pointer to the value",15,N],[11,"clone_from_slice","","Assign self to be of the same value as a slice of bytes of length `len()`.",15,N],[11,"from_slice","","Convert a slice of bytes of length `len()` to an instance of this type.",15,N],[11,"copy_to","","Copy the data of this object into some mutable slice of length `len()`.",15,N],[11,"contains","","Returns `true` if all bits set in `b` are also set in `self`.",15,[[["self"],["h2048"]],["bool"]]],[11,"is_zero","","Returns `true` if no bits are set.",15,[[["self"]],["bool"]]],[11,"low_u64","","Returns the lowest 8 bytes interpreted as a BigEndian integer.",15,[[["self"]],["u64"]]],[18,"MAX","","",16,N],[11,"from_dec_str","","Convert from a decimal string.",16,[[["str"]],["result",["u256","fromdecstrerr"]]]],[11,"low_u32","","Conversion to u32",16,[[["self"]],["u32"]]],[11,"low_u64","","Conversion to u64",16,[[["self"]],["u64"]]],[11,"as_u32","","Conversion to u32 with overflow checking",16,[[["self"]],["u32"]]],[11,"as_u64","","Conversion to u64 with overflow checking",16,[[["self"]],["u64"]]],[11,"as_usize","","Conversion to usize with overflow checking",16,[[["self"]],["usize"]]],[11,"is_zero","","Whether this is zero.",16,[[["self"]],["bool"]]],[11,"bits","","Return the least number of bits needed to represent the number",16,[[["self"]],["usize"]]],[11,"bit","","Return if specific bit is set.",16,[[["self"],["usize"]],["bool"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",16,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of leading zeros in the binary representation of self.",16,[[["self"]],["u32"]]],[11,"byte","","Return specific byte.",16,[[["self"],["usize"]],["u8"]]],[11,"to_big_endian","","Write to the slice in big-endian format.",16,N],[11,"to_little_endian","","Write to the slice in little-endian format.",16,N],[11,"exp10","","Create `10**n` as this type.",16,[[["usize"]],["u256"]]],[11,"zero","","Zero (additive identity) of this type.",16,[[],["u256"]]],[11,"one","","One (multiplicative identity) of this type.",16,[[],["u256"]]],[11,"max_value","","The maximum value which can be inhabited by this type.",16,[[],["u256"]]],[11,"pow","","Fast exponentation by squaring https://en.wikipedia.org/wiki/Exponentiation_by_squaring",16,[[["self"],["u256"]],["u256"]]],[11,"overflowing_pow","","Fast exponentation by squaring https://en.wikipedia.org/wiki/Exponentiation_by_squaring",16,N],[11,"overflowing_add","","Optimized instructions",16,N],[11,"saturating_add","","Addition which saturates at the maximum value.",16,[[["self"],["u256"]],["u256"]]],[11,"checked_add","","Checked addition. Returns `None` if overflow occurred.",16,[[["self"],["u256"]],["option",["u256"]]]],[11,"overflowing_sub","","Subtraction which underflows and returns a flag if it does.",16,N],[11,"saturating_sub","","Subtraction which saturates at zero.",16,[[["self"],["u256"]],["u256"]]],[11,"checked_sub","","Checked subtraction. Returns `None` if overflow occurred.",16,[[["self"],["u256"]],["option",["u256"]]]],[11,"overflowing_mul","","Multiply with overflow, returning a flag if it does.",16,N],[11,"saturating_mul","","Multiplication which saturates at the maximum value..",16,[[["self"],["u256"]],["u256"]]],[11,"checked_mul","","Checked multiplication. Returns `None` if overflow occurred.",16,[[["self"],["u256"]],["option",["u256"]]]],[11,"overflowing_div","","Division with overflow",16,N],[11,"checked_div","","Checked division. Returns `None` if `other == 0`.",16,[[["self"],["u256"]],["option",["u256"]]]],[11,"overflowing_rem","","Modulus with overflow.",16,N],[11,"checked_rem","","Checked modulus. Returns `None` if `other == 0`.",16,[[["self"],["u256"]],["option",["u256"]]]],[11,"overflowing_neg","","Negation with overflow.",16,N],[11,"checked_neg","","Checked negation. Returns `None` unless `self == 0`.",16,[[["self"]],["option",["u256"]]]],[11,"mul_u32","","Multiplication by u32",16,[[["self"],["u32"]],["u256"]]],[11,"from_big_endian","","Converts from big endian representation bytes in memory Can also be used as (&slice).into(), as it is default `From` slice implementation for U256",16,N],[11,"from_little_endian","","Converts from little endian representation bytes in memory",16,N]],"paths":[[4,"Error"],[3,"Stream"],[3,"Sink"],[8,"AsLog"],[8,"AbiType"],[8,"EndpointInterface"],[3,"H32"],[3,"H64"],[3,"H128"],[3,"H160"],[3,"H256"],[3,"H264"],[3,"H512"],[3,"H520"],[3,"H1024"],[3,"H2048"],[3,"U256"],[6,"Address"],[3,"Vec"]]};
initSearch(searchIndex);
